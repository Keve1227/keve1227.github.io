<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Blockchain</title>

        <style>
            * {
                box-sizing: border-box;
            }

            :root {
                background-color: #18161e;
                color: #f7f7f7;

                font-family: monospace;
                font-size: 16px;
                line-height: 1.5;

                scrollbar-width: thin;
                overflow-y: scroll;
            }

            body {
                margin: 0;
                padding: 0;
            }

            .rail {
                height: calc(100lvh - 100dvh);
            }

            pre {
                margin: 0;
                padding: 1rem;
                white-space: pre-wrap;
                word-wrap: break-word;
            }

            samp {
                display: block;
                margin: 0;
                padding: 0;
            }

            p {
                margin: 0;
                padding: 0;
                margin-bottom: 0.5em;
            }
        </style>

        <script type="application/javascript">
            function bufferToString(buf) {
                return new TextDecoder("ISO-8859-1").decode(buf);
            }

            function countBits(n) {
                let count = 0;
                while (n) {
                    n &= n - 1;
                    count++;
                }

                return count;
            }

            async function digestBlock(block) {
                return crypto.subtle.digest(
                    "SHA-256",
                    new TextEncoder().encode(JSON.stringify({ ...block, hash: undefined }))
                );
            }

            async function makeBlock(data, parent, options = {}) {
                const { difficulty = 36, signal = AbortSignal.timeout(60000) } = options;
                let done = false;

                const block = await Promise.race(
                    [...new Array(6)].map(async () => {
                        while (true) {
                            const block = {
                                parent: parent?.hash ?? null,
                                timestamp: Date.now(),
                                difficulty,
                                nonce: crypto.getRandomValues(new Uint32Array(1))[0],
                                hash: undefined,
                                data,
                            };

                            const hash = await digestBlock(block);
                            if (done) return;

                            if (signal?.aborted) {
                                throw new Error(signal.reason);
                            }

                            let bitCount = 0;
                            for (const n of new Uint8Array(hash)) {
                                bitCount += countBits(n);
                            }

                            if (bitCount >= 128 + difficulty) {
                                done = true;
                                block.hash = bufferToString(hash);
                                return block;
                            }
                        }
                    })
                );

                if (signal?.aborted) {
                    throw new Error(signal.reason);
                }

                return block;
            }

            async function verifyBlock(block, parent = null) {
                if (parent) {
                    if (block.parent !== parent.hash) {
                        return false;
                    }

                    if (block.timestamp < parent.timestamp) {
                        return false;
                    }

                    if (block.difficulty < parent.difficulty) {
                        return false;
                    }
                }

                const hash = await digestBlock(block);

                if (block.hash !== bufferToString(hash)) {
                    return false;
                }

                let bitCount = 0;
                for (const n of new Uint8Array(hash)) {
                    bitCount += countBits(n);
                }

                if (bitCount < 128 + block.difficulty) {
                    return false;
                }

                return true;
            }

            async function* makeChain(data, options = {}) {
                const { signal } = options;
                let parent = null;

                for (const d of data) {
                    const block = await makeBlock(d, parent, options);

                    if (signal?.aborted) {
                        throw new Error(signal.reason);
                    }

                    yield (parent = block);
                }
            }

            async function verifyChain(chain, options = {}) {
                const { signal = AbortSignal.timeout(60000) } = options;
                let parent = null;

                for (const block of chain) {
                    const valid = await verifyBlock(block, parent);

                    if (signal?.aborted) {
                        throw new Error(signal.reason);
                    }

                    if (!valid) {
                        return false;
                    }

                    parent = block;
                }

                return true;
            }
        </script>
    </head>
    <body>
        <pre><samp></samp></pre>
        <div class="rail"></div>

        <script type="application/javascript">
            const log = document.querySelector("samp");
            const rail = document.querySelector(".rail");

            function print(...args) {
                const row = document.createElement("p");
                row.textContent = args.join(" ");
                log.appendChild(row);
                rail.scrollIntoView({ behavior: "smooth", block: "end" });
            }

            (async () => {
                const data = ["Hello", "World", "Foo", "Bar", "Baz"];
                const chain = [];

                performance.mark("mining_start");
                try {
                    print("‚õèÔ∏è Mining...");
                    for await (const block of makeChain(data.slice(0, -1), { difficulty: 36 })) {
                        chain.push(block);
                        print(JSON.stringify(block, null, 4));
                        print("‚õèÔ∏è Mining...");
                    }

                    chain.push(await makeBlock(data.at(-1), chain.at(-1), { difficulty: 36 }));
                    print(JSON.stringify(chain.at(-1), null, 4));
                } catch (e) {
                    console.error(e);
                    print(`‚ö†Ô∏è Mining failed (${e.message ?? "Unknown error"})`);
                }
                performance.mark("mining_end");

                const duration = performance.measure("mining", "mining_start", "mining_end").duration / 1000;
                print(`‚è±Ô∏è ${duration.toFixed(2)}s total`);

                if (chain.length === 0) {
                    print(`‚ÅâÔ∏è No blocks mined`);
                    return;
                }

                print(`üìà ${(duration / chain.length).toFixed(2)}s per block`);

                print("üîó Verifying...");
                const valid = await verifyChain(chain);

                print(valid ? "‚úîÔ∏è Chain is valid" : "‚ùå Chain is invalid");
            })();
        </script>
    </body>
</html>
